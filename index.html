<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Power Nuke Admin CDN</title>
  <link rel="stylesheet" href="MainCSS.css">
  <style>
    body { background: #111; color: #eee; font-family: sans-serif; }
    video { max-width: 90%; max-height: 70vh; background: black; }
    .file-entry { margin: 1em 0; }
    .status { margin-top: 0.5em; font-size: 0.9em; color: #aaa; }
  </style>
</head>
<body>
  <h1>Power Nuke Admin CDN</h1>
  <div id="app">Loading‚Ä¶</div>

  <script>
    // Convert github.com/raw links to media form
    function toMediaUrl(url) {
      if (url.includes("github.com") && url.includes("/raw/")) {
        return url
          .replace("https://github.com/", "https://media.githubusercontent.com/media/")
          .replace("/raw/refs/heads/", "/refs/heads/");
      }
      return url;
    }

    // Decode base64 chunk into Uint8Array
    function decodeBase64Chunk(b64) {
      const byteChars = atob(b64);
      const bytes = new Uint8Array(byteChars.length);
      for (let i = 0; i < byteChars.length; i++) {
        bytes[i] = byteChars.charCodeAt(i);
      }
      return bytes;
    }

    // Fetch distributed manifest + chunks, decode incrementally
    async function fetchDistributed(manifestLink, statusEl) {
      const res = await fetch(toMediaUrl(manifestLink));
      if (!res.ok) throw new Error(`Failed to fetch manifest: ${res.status}`);
      const manifest = await res.json();

      const byteArrays = [];
      let buffer = "";

      for (let i = 0; i < manifest.parts.length; i++) {
        const partUrl = toMediaUrl(manifest.parts[i]);
        statusEl.textContent = `‚¨áÔ∏è Fetching chunk ${i+1}/${manifest.parts.length}‚Ä¶`;
        const chunk = await fetch(partUrl).then(r => r.text());
        buffer += chunk;

        // Flush every 5 chunks (tune as needed)
        if (i % 5 === 4 || i === manifest.parts.length - 1) {
          const bytes = decodeBase64Chunk(buffer);
          byteArrays.push(bytes);
          buffer = "";
        }
      }

      // Merge all byte arrays
      const totalLength = byteArrays.reduce((sum, arr) => sum + arr.length, 0);
      const merged = new Uint8Array(totalLength);
      let offset = 0;
      for (const arr of byteArrays) {
        merged.set(arr, offset);
        offset += arr.length;
      }

      return { blob: new Blob([merged], { type: "video/mp4" }), originalName: manifest.original };
    }

    // === Routing logic ===
    const params = new URLSearchParams(window.location.search);
    const uuid = params.get("id");
    const app = document.getElementById("app");

    fetch("uploads/manifest.json")
      .then(res => res.json())
      .then(data => {
        if (!uuid) {
          // List view
          app.innerHTML = "<h2>Available Videos</h2>";
          const ul = document.createElement("ul");
          for (const [filename, meta] of Object.entries(data)) {
            const li = document.createElement("li");
            li.className = "file-entry";
            li.innerHTML = `<a href="?id=${meta.uuid}">${filename} <small>[${meta.type}]</small></a>`;
            ul.appendChild(li);
          }
          app.appendChild(ul);
        } else {
          // Single video view
          const entry = Object.values(data).find(v => v.uuid === uuid);
          if (!entry) {
            app.textContent = "‚ùå Video not found.";
            return;
          }
          const filename = Object.keys(data).find(k => data[k].uuid === uuid);

          app.innerHTML = `
            <div class="file-entry">
              <h2>${filename}</h2>
              <p>UUID: <code>${entry.uuid}</code></p>
              <p>Timestamp: <code>${entry.timestamp}</code></p>
              <video id="player" controls></video>
              <div class="controls">
                <button onclick="player.play()">‚ñ∂Ô∏è Play</button>
                <button onclick="player.pause()">‚è∏Ô∏è Pause</button>
                <button onclick="player.currentTime -= 10">‚è™ Rewind 10s</button>
              </div>
              <div class="duration" id="duration">‚è±Ô∏è Duration: loading‚Ä¶</div>
              <a id="downloadLink" href="#" download><button>üì• Download</button></a>
              <p><a href="./">‚¨ÖÔ∏è Back to list</a></p>
              <div id="status" class="status"></div>
            </div>
          `;

          const player = document.getElementById("player");
          const statusEl = document.getElementById("status");
          const downloadEl = document.getElementById("downloadLink");

          player.addEventListener("loadedmetadata", () => {
            const dur = Math.floor(player.duration);
            const min = Math.floor(dur / 60);
            const sec = dur % 60;
            document.getElementById("duration").textContent =
              `‚è±Ô∏è Duration: ${min}m ${sec}s`;
          });

          if (entry.type === "Pure") {
            const mediaLink = toMediaUrl(entry.link);
            player.src = mediaLink;
            downloadEl.href = mediaLink;
            downloadEl.download = filename;
          } else if (entry.type === "Distributed") {
            statusEl.textContent = "‚¨áÔ∏è Fetching distributed manifest and chunks‚Ä¶";
            fetchDistributed(entry.link, statusEl)
              .then(({ blob, originalName }) => {
                statusEl.textContent = "üîß Reassembling video data‚Ä¶";
                const url = URL.createObjectURL(blob);
                player.src = url;
                player.load();
                player.play();

                downloadEl.href = url;
                downloadEl.download = originalName || filename;
                statusEl.textContent = "‚úÖ Ready";
              })
              .catch(err => {
                console.error(err);
                statusEl.textContent = `‚ö†Ô∏è Failed: ${err.message}`;
                document.getElementById("duration").textContent = "‚è±Ô∏è Duration: unavailable";
              });
          }
        }
      })
      .catch(err => {
        app.textContent = "‚ö†Ô∏è Failed to load manifest.";
        console.error(err);
      });
  </script>
</body>
</html>
